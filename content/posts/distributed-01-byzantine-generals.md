---
title: "åˆ†å¸ƒå¼ç³»ç»ŸåŸºç¡€ï¼šæ‹œå åº­å°†å†›é—®é¢˜æ·±åº¦è§£æ"
date: 2024-09-19T10:00:00+08:00
draft: false
tags: ["åˆ†å¸ƒå¼ç³»ç»Ÿ", "æ‹œå åº­å°†å†›", "å®¹é”™ç®—æ³•", "å…±è¯†ç®—æ³•"]
categories: ["åˆ†å¸ƒå¼ç³»ç»Ÿ"]
author: "lesshash"
description: "æ·±å…¥ç†è§£æ‹œå åº­å°†å†›é—®é¢˜ï¼šåˆ†å¸ƒå¼ç³»ç»Ÿå®¹é”™çš„ç»å…¸é—®é¢˜ï¼Œä»ç†è®ºåŸºç¡€åˆ°å®é™…åº”ç”¨çš„å®Œæ•´è§£æ"
---

## å¼•è¨€

æƒ³è±¡ä¸€ä¸‹ï¼Œä½ æ­£åœ¨ä½¿ç”¨æ”¯ä»˜å®è½¬è´¦ç»™æœ‹å‹ï¼Œä½†æ˜¯ç½‘ç»œä¸­å­˜åœ¨æ¶æ„æ”»å‡»è€…è¯•å›¾ç¯¡æ”¹äº¤æ˜“ä¿¡æ¯ã€‚å¦‚ä½•ç¡®ä¿ä½ çš„è½¬è´¦èƒ½å¤Ÿå®‰å…¨ã€å‡†ç¡®åœ°å®Œæˆï¼Ÿè¿™å°±æ˜¯æ‹œå åº­å°†å†›é—®é¢˜è¦è§£å†³çš„æ ¸å¿ƒæŒ‘æˆ˜ã€‚

æ‹œå åº­å°†å†›é—®é¢˜æ˜¯åˆ†å¸ƒå¼è®¡ç®—ä¸­æœ€ç»å…¸çš„é—®é¢˜ä¹‹ä¸€ï¼Œå®ƒç”¨ä¸€ä¸ªç”ŸåŠ¨çš„å†›äº‹éšå–»æè¿°äº†åœ¨å­˜åœ¨æ¶æ„èŠ‚ç‚¹çš„åˆ†å¸ƒå¼ç³»ç»Ÿä¸­å¦‚ä½•è¾¾æˆå…±è¯†çš„æŒ‘æˆ˜ã€‚è¿™ä¸ªé—®é¢˜ä¸ä»…æ˜¯ç†è®ºç ”ç©¶çš„åŸºçŸ³ï¼Œæ›´æ˜¯ç°ä»£åŒºå—é“¾ã€åˆ†å¸ƒå¼æ•°æ®åº“ã€äº‘è®¡ç®—ç­‰ç³»ç»Ÿè®¾è®¡çš„æ ¸å¿ƒè€ƒé‡ã€‚

### ä¸ºä»€ä¹ˆè¦äº†è§£æ‹œå åº­å°†å†›é—®é¢˜ï¼Ÿ

- ğŸŒ **äº’è”ç½‘å®‰å…¨**ï¼šç†è§£ç½‘ç»œä¸­æ¶æ„èŠ‚ç‚¹çš„å¨èƒ
- ğŸ’° **æ•°å­—è´§å¸**ï¼šåŒºå—é“¾å…±è¯†æœºåˆ¶çš„ç†è®ºåŸºç¡€
- ğŸ¢ **ä¼ä¸šåº”ç”¨**ï¼šåˆ†å¸ƒå¼æ•°æ®åº“çš„ä¸€è‡´æ€§ä¿è¯
- ğŸ›¡ï¸ **ç³»ç»Ÿè®¾è®¡**ï¼šæ„å»ºå®¹é”™åˆ†å¸ƒå¼ç³»ç»Ÿçš„æŒ‡å¯¼åŸåˆ™

## é—®é¢˜æè¿°

### ğŸ“š ç»å…¸æ•…äº‹ï¼šæ‹œå åº­å¸å›½çš„å†›äº‹éš¾é¢˜

å…¬å…ƒ1000å¹´ï¼Œæ‹œå åº­å¸å›½çš„å°†å†›ä»¬å›´æ”»ä¸€åº§æ•Œæ–¹åŸå¸‚ã€‚ä»–ä»¬é¢ä¸´ä¸€ä¸ªç”Ÿæ­»æ”¸å…³çš„å†³ç­–ï¼š

```mermaid
flowchart TD
    City["æ•Œæ–¹åŸå¸‚"]
    GeneralA["å°†å†›A - å¿ è¯š"]
    GeneralB["å°†å†›B - å›å¾’"]
    GeneralC["å°†å†›C - å¿ è¯š"]
    GeneralD["å°†å†›D - å¿ è¯š"]

    GeneralA -.->|ä¿¡ä½¿| GeneralB
    GeneralB -.->|ä¿¡ä½¿| GeneralC
    GeneralC -.->|ä¿¡ä½¿| GeneralD
    GeneralD -.->|ä¿¡ä½¿| GeneralA
    GeneralA -.->|ä¿¡ä½¿| GeneralC
    GeneralB -.->|ä¿¡ä½¿| GeneralD

    style GeneralB fill:#ffcccb
    style GeneralA fill:#90EE90
    style GeneralC fill:#90EE90
    style GeneralD fill:#90EE90
```

### ğŸ¯ æ ¸å¿ƒæŒ‘æˆ˜

| çº¦æŸæ¡ä»¶ | å…·ä½“å«ä¹‰ | ç°å®å¯¹åº” |
|---------|----------|----------|
| ğŸ”„ **åˆ†å¸ƒå¼é€šä¿¡** | å°†å†›ä»¬åªèƒ½é€šè¿‡ä¿¡ä½¿ä¼ é€’æ¶ˆæ¯ | ç½‘ç»œèŠ‚ç‚¹é—´çš„æ¶ˆæ¯ä¼ é€’ |
| ğŸ­ **æ¶æ„èŠ‚ç‚¹** | éƒ¨åˆ†å°†å†›å¯èƒ½æ˜¯å›å¾’ï¼Œå‘é€è™šå‡ä¿¡æ¯ | ç³»ç»Ÿä¸­çš„æ¶æ„æ”»å‡»è€… |
| ğŸ¤ **ä¸€è‡´æ€§è¦æ±‚** | å¿ è¯šçš„å°†å†›å¿…é¡»è¾¾æˆä¸€è‡´å†³ç­– | åˆ†å¸ƒå¼ç³»ç»Ÿçš„çŠ¶æ€åŒæ­¥ |
| â° **æ—¶é—´é™åˆ¶** | å¿…é¡»åœ¨æœ‰é™æ—¶é—´å†…åšå‡ºå†³ç­– | ç³»ç»Ÿå“åº”æ—¶é—´è¦æ±‚ |

### ğŸŒ ç°ä»£åº”ç”¨åœºæ™¯

**åŒºå—é“¾ç½‘ç»œ**
```
èŠ‚ç‚¹A (è¯šå®) â†â†’ èŠ‚ç‚¹B (æ¶æ„)
    â†•              â†•
èŠ‚ç‚¹C (è¯šå®) â†â†’ èŠ‚ç‚¹D (è¯šå®)

é—®é¢˜ï¼šå¦‚ä½•ç¡®ä¿è¯šå®èŠ‚ç‚¹å¯¹äº¤æ˜“è¾¾æˆå…±è¯†ï¼Ÿ
```

**åˆ†å¸ƒå¼æ•°æ®åº“**
```
æ•°æ®åº“1 â†â†’ æ•°æ®åº“2 (æ•…éšœ)
    â†•           â†•
æ•°æ®åº“3 â†â†’ æ•°æ®åº“4

é—®é¢˜ï¼šå¦‚ä½•ä¿è¯æ•°æ®çš„ä¸€è‡´æ€§å’Œå®Œæ•´æ€§ï¼Ÿ
```

### ğŸ”¬ å½¢å¼åŒ–å®šä¹‰

```mermaid
flowchart TD
    subgraph "ç³»ç»Ÿæ¨¡å‹"
        A["è¯šå®èŠ‚ç‚¹é›†åˆ H<br/>|H| = n - f"]
        B["æ‹œå åº­èŠ‚ç‚¹é›†åˆ B<br/>|B| â‰¤ f"]
        C["æ€»èŠ‚ç‚¹æ•° n"]
    end

    subgraph "å…±è¯†ç›®æ ‡"
        D["å…±è¯†å€¼ v"]
    end

    subgraph "å®‰å…¨æ€§è¦æ±‚"
        F["ä¸€è‡´æ€§<br/>æ‰€æœ‰è¯šå®èŠ‚ç‚¹è¾“å‡ºç›¸åŒå€¼"]
        G["æ­£ç¡®æ€§<br/>è¾“å‡ºå€¼æ¥è‡ªè¯šå®èŠ‚ç‚¹è¾“å…¥"]
        H["ç»ˆæ­¢æ€§<br/>ç®—æ³•åœ¨æœ‰é™æ—¶é—´å†…ç»“æŸ"]
    end

    A --> D
    B --> D
    C --> D
    D --> F
    D --> G
    D --> H
```

### ğŸ§® æ•°å­¦è¡¨ç¤º

è®¾åˆ†å¸ƒå¼ç³»ç»Ÿæœ‰ `n` ä¸ªèŠ‚ç‚¹ï¼Œå…¶ä¸­æœ€å¤šæœ‰ `f` ä¸ªæ‹œå åº­æ•…éšœèŠ‚ç‚¹ï¼š

```
ç³»ç»Ÿå‚æ•°ï¼š
â€¢ nï¼šæ€»èŠ‚ç‚¹æ•°
â€¢ fï¼šæœ€å¤§æ‹œå åº­æ•…éšœèŠ‚ç‚¹æ•°
â€¢ Hï¼šè¯šå®èŠ‚ç‚¹é›†åˆï¼Œ|H| = n - f
â€¢ Bï¼šæ‹œå åº­èŠ‚ç‚¹é›†åˆï¼Œ|B| â‰¤ f

å…±è¯†å±æ€§ï¼š
â€¢ Agreementï¼šâˆ€i,j âˆˆ Hï¼Œdecision_i = decision_j
â€¢ Validityï¼šå¦‚æœæ‰€æœ‰è¯šå®èŠ‚ç‚¹è¾“å…¥ç›¸åŒå€¼vï¼Œåˆ™å†³ç­–å€¼ä¸ºv
â€¢ Terminationï¼šæ‰€æœ‰è¯šå®èŠ‚ç‚¹æœ€ç»ˆéƒ½ä¼šäº§ç”Ÿå†³ç­–
```

## ğŸ§  ç†è®ºåˆ†æ

### ğŸš« ä¸å¯èƒ½æ€§å®šç†ï¼ˆFLPå®šç†ï¼‰

**å‘ç°è€…**ï¼šFischer, Lynch, Paterson (1985)

**å®šç†å†…å®¹**ï¼šåœ¨å¼‚æ­¥ç½‘ç»œä¸­ï¼Œå³ä½¿åªæœ‰ä¸€ä¸ªèŠ‚ç‚¹å¯èƒ½æ•…éšœï¼Œä¹Ÿä¸å­˜åœ¨æ—¢ä¿è¯å®‰å…¨æ€§åˆä¿è¯æ´»æ€§çš„ç¡®å®šæ€§å…±è¯†ç®—æ³•ã€‚

```mermaid
flowchart LR
    subgraph "ç½‘ç»œæ¨¡å‹"
        A[åŒæ­¥ç½‘ç»œ<br/>ğŸŸ¢ å¯è§£å†³]
        B[å¼‚æ­¥ç½‘ç»œ<br/>ğŸ”´ ä¸å¯è§£å†³]
        C[éƒ¨åˆ†åŒæ­¥<br/>ğŸŸ¡ æœ‰æ¡ä»¶è§£å†³]
    end

    A --> A1["æ¶ˆæ¯æœ‰ç¡®å®šå»¶è¿Ÿä¸Šç•Œ"]
    B --> B1["æ¶ˆæ¯å»¶è¿Ÿæ— ç•Œ"]
    C --> C1["æœ€ç»ˆåŒæ­¥å‡è®¾"]
```

### ğŸ“ å®¹é”™è¾¹ç•Œåˆ†æ

#### ğŸ”¢ ç¥å¥‡çš„"3f+1"å…¬å¼

æ‹œå åº­å®¹é”™ç³»ç»Ÿå¿…é¡»æ»¡è¶³ï¼š**n â‰¥ 3f + 1**

| ç½‘ç»œç±»å‹ | å®¹é”™æ¡ä»¶ | è¯´æ˜ |
|---------|----------|------|
| ğŸ”„ **åŒæ­¥ç½‘ç»œ** | n â‰¥ 3f + 1 | æ¶ˆæ¯ä¼ é€’æœ‰æ—¶é—´ä¸Šç•Œ |
| âš¡ **å¼‚æ­¥ç½‘ç»œ** | ä¸å¯èƒ½ | FLPå®šç†é™åˆ¶ |
| ğŸŒ“ **éƒ¨åˆ†åŒæ­¥** | n â‰¥ 3f + 1 + é¢å¤–å‡è®¾ | æœ€ç»ˆåŒæ­¥æˆ–æ•…éšœæ£€æµ‹ |

#### ğŸ¤” ä¸ºä»€ä¹ˆæ˜¯"3f+1"è€Œä¸æ˜¯"2f+1"ï¼Ÿ

è®©æˆ‘ä»¬ç”¨ä¸€ä¸ªç›´è§‚çš„ä¾‹å­æ¥ç†è§£ï¼š

```mermaid
flowchart TD
    subgraph "åœºæ™¯ï¼šn=3, f=1"
        A["èŠ‚ç‚¹A<br/>è¯´ï¼šæ”»å‡»"]
        B["èŠ‚ç‚¹B<br/>è¯´ï¼šæ’¤é€€"]
        C["èŠ‚ç‚¹C<br/>ğŸ¤” å›°æƒ‘äº†"]
    end

    A -.->|æ¶ˆæ¯1| C
    B -.->|æ¶ˆæ¯2| C

    subgraph "Cçš„å›°å¢ƒ"
        D["Aæ˜¯è¯šå®çš„ï¼ŒBæ˜¯å›å¾’ï¼Ÿ"]
        E["Bæ˜¯è¯šå®çš„ï¼ŒAæ˜¯å›å¾’ï¼Ÿ"]
        F["ğŸ˜µ æ— æ³•åˆ¤æ–­ï¼"]
    end

    C --> D
    C --> E
    D --> F
    E --> F
```

**ç»“è®º**ï¼š3ä¸ªèŠ‚ç‚¹æ— æ³•å®¹å¿1ä¸ªæ‹œå åº­æ•…éšœï¼

### ğŸ§® æ•°å­¦è¯æ˜ï¼šä¸ºä»€ä¹ˆéœ€è¦ n â‰¥ 3f + 1ï¼Ÿ

#### ğŸ“‹ è¯æ˜æ€è·¯

**æ­¥éª¤1ï¼šåŸºæœ¬çº¦æŸ**
```
è¯šå®èŠ‚ç‚¹æ•° > æ‹œå åº­èŠ‚ç‚¹æ•°
n - f > f
å› æ­¤ï¼šn > 2f
```

**æ­¥éª¤2ï¼šä¿¡æ¯ä¼ é€’å¤æ‚æ€§**

è€ƒè™‘ä¸€ä¸ªæ›´å¤æ‚çš„åœºæ™¯ï¼š

```mermaid
sequenceDiagram
    participant A as èŠ‚ç‚¹A(è¯šå®)
    participant B as èŠ‚ç‚¹B(?)
    participant C as èŠ‚ç‚¹C(è¯šå®)
    participant D as èŠ‚ç‚¹D(?)

    Note over A,D: åˆå§‹æè®®é˜¶æ®µ
    A->>B: æè®®ï¼šæ”»å‡»
    A->>C: æè®®ï¼šæ”»å‡»
    A->>D: æè®®ï¼šæ”»å‡»

    Note over A,D: Bå¯èƒ½æ˜¯å›å¾’çš„æƒ…å†µ
    B->>C: "Aè¯´æ’¤é€€" (è°è¨€)
    B->>D: "Aè¯´æ”»å‡»" (çœŸè¯)

    Note over A,D: Céœ€è¦åšå†³ç­–
    C->>C: æ”¶åˆ°çŸ›ç›¾ä¿¡æ¯ï¼Œå¦‚ä½•åˆ¤æ–­ï¼Ÿ
```

**æ­¥éª¤3ï¼šæœ€åæƒ…å†µåˆ†æ**

å‡è®¾ç³»ç»Ÿè¢«åˆ†ä¸ºä¸¤éƒ¨åˆ†ï¼Œæ‹œå åº­èŠ‚ç‚¹å¯èƒ½å‘ä¸¤éƒ¨åˆ†å‘é€ä¸åŒçš„æ¶ˆæ¯ï¼š

```
æƒ…å†µ1ï¼šç½‘ç»œåˆ†åŒº
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   ç»„ X      â”‚    â”‚    ç»„ Y     â”‚
â”‚ è¯šå®: aä¸ª   â”‚    â”‚  è¯šå®: bä¸ª  â”‚
â”‚ æ‹œå åº­: fä¸ª â”‚    â”‚  æ‹œå åº­: 0ä¸ªâ”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

å…¶ä¸­ï¼ša + b = n - f, a â‰¥ f (ç»„Xèƒ½å¤Ÿæ£€æµ‹æ‹œå åº­è¡Œä¸º)

ä¸ºäº†ä¿è¯æ¯ç»„éƒ½èƒ½æ­£ç¡®å·¥ä½œï¼š
a â‰¥ f ä¸” b â‰¥ f
å› æ­¤ï¼ša + b â‰¥ 2f
å³ï¼šn - f â‰¥ 2f
æ‰€ä»¥ï¼šn â‰¥ 3f
```

**æ­¥éª¤4ï¼šè¾¹ç•Œæ¡ä»¶**

å®é™…ä¸Šéœ€è¦ä¸¥æ ¼å¤§äºï¼š**n â‰¥ 3f + 1**

#### ğŸ¨ ç›´è§‚ç†è§£

```mermaid
flowchart LR
    subgraph "n=4, f=1 (âœ…å¯è¡Œ)"
        A1[è¯šå®]
        A2[è¯šå®]
        A3[è¯šå®]
        A4[å›å¾’]

        A1 -.-> A2
        A2 -.-> A3
        A3 -.-> A1
        A4 -.-> A1
        A4 -.-> A2
        A4 -.-> A3
    end

    subgraph "n=3, f=1 (âŒä¸å¯è¡Œ)"
        B1[è¯šå®]
        B2[è¯šå®]
        B3[å›å¾’]

        B1 -.-> B2
        B3 -.-> B1
        B3 -.-> B2
    end
```

## ğŸ’¡ è§£å†³æ–¹æ¡ˆå¤§å…¨

æ‹œå åº­å°†å†›é—®é¢˜å‚¬ç”Ÿäº†å¤šç§å·§å¦™çš„è§£å†³æ–¹æ¡ˆï¼Œæ¯ç§æ–¹æ¡ˆéƒ½æœ‰å…¶ç‰¹å®šçš„åº”ç”¨åœºæ™¯å’Œä¼˜åŠ¿ã€‚è®©æˆ‘ä»¬ä»æœ€åŸºç¡€çš„ç®—æ³•å¼€å§‹ï¼Œé€æ­¥æ¢ç´¢æ›´å…ˆè¿›çš„è§£å†³æ–¹æ¡ˆã€‚

### 1. å£å¤´æ¶ˆæ¯ç®—æ³• (OMç®—æ³•)

**åŸºæœ¬æ€æƒ³**ï¼šé€šè¿‡å¤šè½®æ¶ˆæ¯ä¼ é€’ï¼Œè®©æ¯ä¸ªèŠ‚ç‚¹æ”¶é›†è¶³å¤Ÿä¿¡æ¯åšå‡ºå†³ç­–ã€‚

```java
import java.util.*;
import java.util.concurrent.ThreadLocalRandom;

public class ByzantineGeneralsOM {
    private int n; // æ€»èŠ‚ç‚¹æ•°
    private int f; // æœ€å¤§æ‹œå åº­èŠ‚ç‚¹æ•°
    private Set<Integer> byzantineNodes;

    public ByzantineGeneralsOM(int n, int f) {
        this.n = n;
        this.f = f;
        this.byzantineNodes = new HashSet<>();
    }

    /**
     * OM(m)ç®—æ³•å®ç°
     * @param commanderValue æŒ‡æŒ¥å®˜çš„åˆå§‹å€¼
     * @param m è½®æ•°ï¼Œé€šå¸¸è®¾ç½®ä¸ºf
     * @return å…±è¯†ç»“æœ
     */
    public int oralMessage(int commanderValue, int m) {
        if (m == 0) {
            // åŸºç¡€æƒ…å†µï¼šç›´æ¥è¿”å›æŒ‡æŒ¥å®˜çš„å€¼
            return commanderValue;
        }

        // ç¬¬ä¸€è½®ï¼šæŒ‡æŒ¥å®˜å‘æ‰€æœ‰å‰¯å®˜å‘é€å€¼
        Map<Integer, Integer> messages = new HashMap<>();
        for (int i = 1; i < n; i++) {
            // æ¨¡æ‹Ÿå¯èƒ½çš„æ‹œå åº­è¡Œä¸º
            if (isByzantine(0)) { // å¦‚æœæŒ‡æŒ¥å®˜æ˜¯æ‹œå åº­çš„
                messages.put(i, byzantineValue(i));
            } else {
                messages.put(i, commanderValue);
            }
        }

        // åç»­è½®æ¬¡ï¼šé€’å½’å¤„ç†
        Map<Integer, Integer> results = new HashMap<>();
        for (int i = 1; i < n; i++) {
            if (!isByzantine(i)) {
                // è¯šå®èŠ‚ç‚¹è¿è¡ŒOM(m-1)
                results.put(i, oralMessage(messages.get(i), m - 1));
            }
        }

        return majorityVote(results);
    }

    /**
     * å¤šæ•°æŠ•ç¥¨å†³ç­–
     */
    private int majorityVote(Map<Integer, Integer> values) {
        Map<Integer, Integer> voteCount = new HashMap<>();
        for (Integer value : values.values()) {
            voteCount.put(value, voteCount.getOrDefault(value, 0) + 1);
        }

        return voteCount.entrySet().stream()
            .max(Map.Entry.comparingByValue())
            .map(Map.Entry::getKey)
            .orElse(0);
    }

    /**
     * æ£€æŸ¥èŠ‚ç‚¹æ˜¯å¦ä¸ºæ‹œå åº­èŠ‚ç‚¹
     */
    private boolean isByzantine(int nodeId) {
        return byzantineNodes.contains(nodeId);
    }

    /**
     * æ‹œå åº­èŠ‚ç‚¹å‘é€çš„æ¶æ„å€¼
     */
    private int byzantineValue(int targetNode) {
        // æ‹œå åº­èŠ‚ç‚¹å¯èƒ½å‘é€ä¸åŒçš„å€¼ç»™ä¸åŒèŠ‚ç‚¹
        return ThreadLocalRandom.current().nextInt(2);
    }

    public void setByzantineNodes(Set<Integer> nodes) {
        this.byzantineNodes = nodes;
    }

    // ä½¿ç”¨ç¤ºä¾‹
    public static void main(String[] args) {
        int n = 4, f = 1; // 4ä¸ªèŠ‚ç‚¹ï¼Œæœ€å¤š1ä¸ªæ‹œå åº­èŠ‚ç‚¹
        ByzantineGeneralsOM bg = new ByzantineGeneralsOM(n, f);
        bg.setByzantineNodes(Set.of(3)); // èŠ‚ç‚¹3æ˜¯æ‹œå åº­èŠ‚ç‚¹

        int result = bg.oralMessage(1, f);
        System.out.println("å…±è¯†ç»“æœ: " + result);
    }
}
```

**ç®—æ³•æµç¨‹å›¾**ï¼š

```
OM(m)ç®—æ³•æµç¨‹ï¼š

è½®æ¬¡0ï¼šæŒ‡æŒ¥å®˜ â†’ æ‰€æœ‰å‰¯å®˜
â”Œâ”€â”€â”€â”€â”€â”    1    â”Œâ”€â”€â”€â”€â”€â”
â”‚ å°†å†›0â”‚ â”€â”€â”€â”€â”€â”€â†’ â”‚ å°†å†›1â”‚
â”‚(æŒ‡æŒ¥)â”‚    1    â”‚     â”‚
â””â”€â”€â”€â”€â”€â”˜ â”€â”€â”€â”€â”€â”€â†’ â”Œâ”€â”€â”€â”€â”€â”
   â”‚       1    â”‚ å°†å†›2â”‚
   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â†’ â”‚     â”‚
              â””â”€â”€â”€â”€â”€â”˜

è½®æ¬¡1ï¼šæ¯ä¸ªå‰¯å®˜ä½œä¸ºæŒ‡æŒ¥å®˜
å°†å†›1 â†’ {å°†å†›2}: å€¼1
å°†å†›2 â†’ {å°†å†›1}: å€¼1

å†³ç­–é˜¶æ®µï¼š
å°†å†›1æ”¶åˆ°: [1(æ¥è‡ªæŒ‡æŒ¥å®˜), 1(æ¥è‡ªå°†å†›2)]
å°†å†›2æ”¶åˆ°: [1(æ¥è‡ªæŒ‡æŒ¥å®˜), 1(æ¥è‡ªå°†å†›1)]
â†’ å…±è¯†ï¼šæ”»å‡»(1)
```

### 2. ç­¾åæ¶ˆæ¯ç®—æ³• (SMç®—æ³•)

å¼•å…¥æ•°å­—ç­¾åæœºåˆ¶ï¼Œæé«˜æ•ˆç‡å’Œå®‰å…¨æ€§ï¼š

```java
import java.security.*;
import java.security.spec.PKCS8EncodedKeySpec;
import java.security.spec.X509EncodedKeySpec;
import java.util.*;
import java.util.stream.Collectors;
import javax.crypto.Cipher;

class SignatureEntry {
    private int signerId;
    private String signature;

    public SignatureEntry(int signerId, String signature) {
        this.signerId = signerId;
        this.signature = signature;
    }

    public int getSignerId() { return signerId; }
    public String getSignature() { return signature; }
}

class SignedMessage {
    private int value;
    private int senderId;
    private List<SignatureEntry> signatureChain;

    public SignedMessage(int value, int senderId) {
        this.value = value;
        this.senderId = senderId;
        this.signatureChain = new ArrayList<>();
    }

    public SignedMessage(int value, int senderId, List<SignatureEntry> chain) {
        this.value = value;
        this.senderId = senderId;
        this.signatureChain = new ArrayList<>(chain);
    }

    /**
     * ä¸ºæ¶ˆæ¯æ·»åŠ æ•°å­—ç­¾å
     */
    public SignedMessage sign(PrivateKey privateKey, int signerId) throws Exception {
        // åˆ›å»ºæ¶ˆæ¯æ‘˜è¦
        String messageData = String.format("{value:%d,senderId:%d,chainSize:%d}",
                                          value, senderId, signatureChain.size());

        // ç”Ÿæˆç­¾å
        Signature signature = Signature.getInstance("SHA256withRSA");
        signature.initSign(privateKey);
        signature.update(messageData.getBytes());
        byte[] signatureBytes = signature.sign();

        // æ·»åŠ åˆ°ç­¾åé“¾
        signatureChain.add(new SignatureEntry(signerId,
                          Base64.getEncoder().encodeToString(signatureBytes)));

        return this;
    }

    public int getValue() { return value; }
    public int getSenderId() { return senderId; }
    public List<SignatureEntry> getSignatureChain() { return signatureChain; }
}

public class ByzantineGeneralsSM {
    private int n;
    private int f;
    private Map<Integer, KeyPair> keyPairs;
    private Set<Integer> byzantineNodes;

    public ByzantineGeneralsSM(int n, int f) throws Exception {
        this.n = n;
        this.f = f;
        this.byzantineNodes = new HashSet<>();
        generateKeys();
    }

    /**
     * ä¸ºæ¯ä¸ªèŠ‚ç‚¹ç”Ÿæˆå…¬ç§é’¥å¯¹
     */
    private void generateKeys() throws Exception {
        keyPairs = new HashMap<>();
        KeyPairGenerator keyGen = KeyPairGenerator.getInstance("RSA");
        keyGen.initialize(2048);

        for (int i = 0; i < n; i++) {
            KeyPair keyPair = keyGen.generateKeyPair();
            keyPairs.put(i, keyPair);
        }
    }

    /**
     * SMç®—æ³•å®ç°
     */
    public Map<Integer, Integer> signedMessageAlgorithm(int commanderValue, int commanderId)
            throws Exception {

        // ç¬¬ä¸€é˜¶æ®µï¼šæŒ‡æŒ¥å®˜ç­¾åå¹¶å¹¿æ’­
        SignedMessage initialMessage = new SignedMessage(commanderValue, commanderId);
        initialMessage.sign(keyPairs.get(commanderId).getPrivate(), commanderId);

        // æ¨¡æ‹Ÿæ¶ˆæ¯ä¼ æ’­
        Map<Integer, List<SignedMessage>> nodeMessages = new HashMap<>();
        for (int i = 0; i < n; i++) {
            nodeMessages.put(i, new ArrayList<>());
        }

        // æŒ‡æŒ¥å®˜å‘æ‰€æœ‰èŠ‚ç‚¹å‘é€ç­¾åæ¶ˆæ¯
        for (int i = 0; i < n; i++) {
            if (i != commanderId) {
                nodeMessages.get(i).add(initialMessage);
            }
        }

        // å¤šè½®è½¬å‘å’Œç­¾å
        for (int round = 0; round < f; round++) {
            Map<Integer, List<SignedMessage>> newMessages = new HashMap<>();
            for (int i = 0; i < n; i++) {
                newMessages.put(i, new ArrayList<>());
            }

            for (int nodeId = 0; nodeId < n; nodeId++) {
                if (nodeId == commanderId || isByzantine(nodeId)) {
                    continue;
                }

                // è¯šå®èŠ‚ç‚¹è½¬å‘æ”¶åˆ°çš„æ¶ˆæ¯
                for (SignedMessage msg : nodeMessages.get(nodeId)) {
                    if (msg.getSignatureChain().size() <= f) {
                        // æ·»åŠ è‡ªå·±çš„ç­¾åå¹¶è½¬å‘
                        SignedMessage forwardedMsg = new SignedMessage(
                            msg.getValue(), msg.getSenderId(), msg.getSignatureChain());
                        forwardedMsg.sign(keyPairs.get(nodeId).getPrivate(), nodeId);

                        // å‘é€ç»™å…¶ä»–èŠ‚ç‚¹
                        Set<Integer> signerIds = msg.getSignatureChain().stream()
                            .map(SignatureEntry::getSignerId)
                            .collect(Collectors.toSet());

                        for (int targetId = 0; targetId < n; targetId++) {
                            if (targetId != nodeId && !signerIds.contains(targetId)) {
                                newMessages.get(targetId).add(forwardedMsg);
                            }
                        }
                    }
                }
            }

            // æ›´æ–°æ¶ˆæ¯é›†åˆ
            for (int nodeId = 0; nodeId < n; nodeId++) {
                nodeMessages.get(nodeId).addAll(newMessages.get(nodeId));
            }
        }

        // å†³ç­–é˜¶æ®µ
        Map<Integer, Integer> decisions = new HashMap<>();
        for (int nodeId = 0; nodeId < n; nodeId++) {
            if (!isByzantine(nodeId)) {
                decisions.put(nodeId, makeDecision(nodeMessages.get(nodeId)));
            }
        }

        return decisions;
    }

    /**
     * éªŒè¯ç­¾åé“¾çš„æœ‰æ•ˆæ€§
     */
    private boolean verifySignatureChain(SignedMessage message) {
        // ç®€åŒ–å®ç°ï¼Œå®é™…ä¸­éœ€è¦å®Œæ•´çš„ç­¾åéªŒè¯
        Set<Integer> signerIds = message.getSignatureChain().stream()
            .map(SignatureEntry::getSignerId)
            .collect(Collectors.toSet());
        return signerIds.size() >= f + 1;
    }

    /**
     * åŸºäºæ”¶åˆ°çš„æ¶ˆæ¯åšå‡ºå†³ç­–
     */
    private Integer makeDecision(List<SignedMessage> messages) {
        List<SignedMessage> validMessages = messages.stream()
            .filter(this::verifySignatureChain)
            .collect(Collectors.toList());

        if (validMessages.isEmpty()) {
            return null; // é»˜è®¤å€¼
        }

        // é€‰æ‹©å…·æœ‰æœ€å¤šæœ‰æ•ˆç­¾åçš„å€¼
        Map<Integer, Integer> valueCounts = new HashMap<>();
        for (SignedMessage msg : validMessages) {
            int value = msg.getValue();
            int weight = msg.getSignatureChain().size();
            valueCounts.put(value, valueCounts.getOrDefault(value, 0) + weight);
        }

        return valueCounts.entrySet().stream()
            .max(Map.Entry.comparingByValue())
            .map(Map.Entry::getKey)
            .orElse(null);
    }

    /**
     * æ£€æŸ¥æ˜¯å¦ä¸ºæ‹œå åº­èŠ‚ç‚¹
     */
    private boolean isByzantine(int nodeId) {
        return byzantineNodes.contains(nodeId);
    }

    public void setByzantineNodes(Set<Integer> nodes) {
        this.byzantineNodes = nodes;
    }

    // ä½¿ç”¨ç¤ºä¾‹
    public static void main(String[] args) throws Exception {
        ByzantineGeneralsSM bgSm = new ByzantineGeneralsSM(4, 1);
        bgSm.setByzantineNodes(Set.of(3));

        Map<Integer, Integer> decisions = bgSm.signedMessageAlgorithm(1, 0);
        System.out.println("å„èŠ‚ç‚¹å†³ç­–ç»“æœ: " + decisions);
    }
}
```

## ç°ä»£åº”ç”¨

### 1. åŒºå—é“¾ä¸­çš„åº”ç”¨

```java
import java.util.*;
import java.util.concurrent.ConcurrentHashMap;
import java.time.Instant;

class BlockProposal {
    private int view;
    private int sequence;
    private String blockData;
    private long timestamp;

    public BlockProposal(int view, int sequence, String blockData) {
        this.view = view;
        this.sequence = sequence;
        this.blockData = blockData;
        this.timestamp = Instant.now().toEpochMilli();
    }

    // Getters
    public int getView() { return view; }
    public int getSequence() { return sequence; }
    public String getBlockData() { return blockData; }
    public long getTimestamp() { return timestamp; }
}

class Validator {
    private int id;
    private boolean isByzantine;

    public Validator(int id, boolean isByzantine) {
        this.id = id;
        this.isByzantine = isByzantine;
    }

    public boolean validateProposal(BlockProposal proposal) {
        // ç®€åŒ–çš„éªŒè¯é€»è¾‘
        return !isByzantine && proposal.getBlockData() != null;
    }

    public String signPreprepare(BlockProposal proposal) {
        return "preprepare_" + id + "_" + proposal.getSequence();
    }

    public String signPrepare(BlockProposal proposal) {
        return "prepare_" + id + "_" + proposal.getSequence();
    }

    public String signCommit(BlockProposal proposal) {
        return "commit_" + id + "_" + proposal.getSequence();
    }

    public int getId() { return id; }
}

public class BlockchainBFT {
    private List<Validator> validators;
    private int f; // æœ€å¤§æ‹œå åº­èŠ‚ç‚¹æ•°
    private int currentView;
    private int sequenceNumber;

    public BlockchainBFT(List<Validator> validators) {
        this.validators = validators;
        this.f = (validators.size() - 1) / 3;
        this.currentView = 0;
        this.sequenceNumber = 0;
    }

    /**
     * æè®®æ–°åŒºå—
     */
    public boolean proposeBlock(String blockData) {
        // PBFTä¸‰é˜¶æ®µåè®®

        // 1. Pre-prepareé˜¶æ®µ
        BlockProposal proposal = new BlockProposal(currentView, sequenceNumber++, blockData);
        List<String> preprepareVotes = broadcastPreprepare(proposal);

        // 2. Prepareé˜¶æ®µ
        if (preprepareVotes.size() >= 2 * f + 1) {
            List<String> prepareVotes = broadcastPrepare(proposal);

            // 3. Commité˜¶æ®µ
            if (prepareVotes.size() >= 2 * f + 1) {
                List<String> commitVotes = broadcastCommit(proposal);

                if (commitVotes.size() >= 2 * f + 1) {
                    return finalizeBlock(blockData);
                }
            }
        }

        return false;
    }

    /**
     * å¹¿æ’­pre-prepareæ¶ˆæ¯
     */
    private List<String> broadcastPreprepare(BlockProposal proposal) {
        List<String> votes = new ArrayList<>();
        for (Validator validator : validators) {
            if (validator.validateProposal(proposal)) {
                String vote = validator.signPreprepare(proposal);
                votes.add(vote);
            }
        }
        return votes;
    }

    /**
     * å¹¿æ’­prepareæ¶ˆæ¯
     */
    private List<String> broadcastPrepare(BlockProposal proposal) {
        List<String> votes = new ArrayList<>();
        for (Validator validator : validators) {
            if (validator.validateProposal(proposal)) {
                String vote = validator.signPrepare(proposal);
                votes.add(vote);
            }
        }
        return votes;
    }

    /**
     * å¹¿æ’­commitæ¶ˆæ¯
     */
    private List<String> broadcastCommit(BlockProposal proposal) {
        List<String> votes = new ArrayList<>();
        for (Validator validator : validators) {
            if (validator.validateProposal(proposal)) {
                String vote = validator.signCommit(proposal);
                votes.add(vote);
            }
        }
        return votes;
    }

    /**
     * æœ€ç»ˆç¡®è®¤åŒºå—
     */
    private boolean finalizeBlock(String blockData) {
        System.out.println("åŒºå—å·²ç¡®è®¤: " + blockData);
        return true;
    }

    // ä½¿ç”¨ç¤ºä¾‹
    public static void main(String[] args) {
        List<Validator> validators = Arrays.asList(
            new Validator(0, false),
            new Validator(1, false),
            new Validator(2, false),
            new Validator(3, true)  // æ‹œå åº­èŠ‚ç‚¹
        );

        BlockchainBFT bft = new BlockchainBFT(validators);
        boolean success = bft.proposeBlock("æ–°åŒºå—æ•°æ®");
        System.out.println("åŒºå—æè®®ç»“æœ: " + success);
    }
}
```

### 2. åˆ†å¸ƒå¼æ•°æ®åº“

```java
import java.util.*;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

class Transaction {
    private String id;
    private List<String> operations;
    private long timestamp;

    public Transaction(String id, List<String> operations) {
        this.id = id;
        this.operations = operations;
        this.timestamp = System.currentTimeMillis();
    }

    public String getId() { return id; }
    public List<String> getOperations() { return operations; }
    public long getTimestamp() { return timestamp; }
}

class TransactionProposal {
    private String txId;
    private List<String> operations;
    private long timestamp;

    public TransactionProposal(String txId, List<String> operations, long timestamp) {
        this.txId = txId;
        this.operations = operations;
        this.timestamp = timestamp;
    }

    public String getTxId() { return txId; }
    public List<String> getOperations() { return operations; }
    public long getTimestamp() { return timestamp; }
}

class DatabaseReplica {
    private int id;
    private boolean isByzantine;
    private Map<String, String> data;

    public DatabaseReplica(int id, boolean isByzantine) {
        this.id = id;
        this.isByzantine = isByzantine;
        this.data = new ConcurrentHashMap<>();
    }

    public boolean validateTransaction(Transaction transaction) {
        // ç®€åŒ–çš„äº‹åŠ¡éªŒè¯é€»è¾‘
        return !isByzantine && transaction.getOperations() != null && !transaction.getOperations().isEmpty();
    }

    public String voteCommit(TransactionProposal proposal) {
        if (isByzantine) {
            // æ‹œå åº­èŠ‚ç‚¹å¯èƒ½å‘é€æ¶æ„æŠ•ç¥¨
            return "byzantine_vote_" + id;
        }
        return "commit_vote_" + id + "_" + proposal.getTxId();
    }

    public boolean commitTransaction(Transaction transaction) {
        if (isByzantine) {
            return false; // æ‹œå åº­èŠ‚ç‚¹å¯èƒ½æ‹’ç»æäº¤
        }

        // æ¨¡æ‹Ÿäº‹åŠ¡æäº¤
        for (String operation : transaction.getOperations()) {
            data.put("tx_" + transaction.getId(), operation);
        }
        System.out.println("å‰¯æœ¬ " + id + " æäº¤äº‹åŠ¡: " + transaction.getId());
        return true;
    }

    public void abortTransaction(Transaction transaction) {
        System.out.println("å‰¯æœ¬ " + id + " ä¸­æ­¢äº‹åŠ¡: " + transaction.getId());
    }

    public int getId() { return id; }
}

public class DistributedDatabase {
    private List<DatabaseReplica> replicas;
    private int f; // æœ€å¤§æ‹œå åº­èŠ‚ç‚¹æ•°
    private ExecutorService executor;

    public DistributedDatabase(List<DatabaseReplica> replicas) {
        this.replicas = replicas;
        this.f = (replicas.size() - 1) / 3;
        this.executor = Executors.newCachedThreadPool();
    }

    /**
     * æ‰§è¡Œäº‹åŠ¡
     */
    public boolean executeTransaction(Transaction transaction) {
        // ä½¿ç”¨æ‹œå åº­å®¹é”™ç¡®ä¿äº‹åŠ¡ä¸€è‡´æ€§

        // 1. äº‹åŠ¡æè®®é˜¶æ®µ
        TransactionProposal proposal = new TransactionProposal(
            transaction.getId(),
            transaction.getOperations(),
            transaction.getTimestamp()
        );

        // 2. æŠ•ç¥¨é˜¶æ®µ
        List<String> votes = new ArrayList<>();
        List<CompletableFuture<String>> voteFutures = new ArrayList<>();

        for (DatabaseReplica replica : replicas) {
            CompletableFuture<String> future = CompletableFuture.supplyAsync(() -> {
                if (replica.validateTransaction(transaction)) {
                    return replica.voteCommit(proposal);
                }
                return null;
            }, executor);
            voteFutures.add(future);
        }

        // æ”¶é›†æŠ•ç¥¨ç»“æœ
        for (CompletableFuture<String> future : voteFutures) {
            try {
                String vote = future.get();
                if (vote != null && !vote.startsWith("byzantine")) {
                    votes.add(vote);
                }
            } catch (Exception e) {
                System.err.println("æŠ•ç¥¨æ”¶é›†å¼‚å¸¸: " + e.getMessage());
            }
        }

        // 3. å†³ç­–é˜¶æ®µ
        if (votes.size() >= 2 * f + 1) {
            // æäº¤äº‹åŠ¡
            System.out.println("äº‹åŠ¡ " + transaction.getId() + " è·å¾—è¶³å¤ŸæŠ•ç¥¨ï¼Œå¼€å§‹æäº¤");
            for (DatabaseReplica replica : replicas) {
                replica.commitTransaction(transaction);
            }
            return true;
        } else {
            // å›æ»šäº‹åŠ¡
            System.out.println("äº‹åŠ¡ " + transaction.getId() + " æŠ•ç¥¨ä¸è¶³ï¼Œå¼€å§‹å›æ»š");
            for (DatabaseReplica replica : replicas) {
                replica.abortTransaction(transaction);
            }
            return false;
        }
    }

    public void shutdown() {
        executor.shutdown();
    }

    // ä½¿ç”¨ç¤ºä¾‹
    public static void main(String[] args) {
        List<DatabaseReplica> replicas = Arrays.asList(
            new DatabaseReplica(0, false),
            new DatabaseReplica(1, false),
            new DatabaseReplica(2, false),
            new DatabaseReplica(3, true)  // æ‹œå åº­èŠ‚ç‚¹
        );

        DistributedDatabase db = new DistributedDatabase(replicas);

        Transaction tx = new Transaction("tx_001",
            Arrays.asList("INSERT user1", "UPDATE balance"));

        boolean success = db.executeTransaction(tx);
        System.out.println("äº‹åŠ¡æ‰§è¡Œç»“æœ: " + success);

        db.shutdown();
    }
}
```

## æ€§èƒ½åˆ†æ

### å¤æ‚åº¦å¯¹æ¯”

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ ç®—æ³•ç±»å‹         â”‚ æ¶ˆæ¯å¤æ‚åº¦    â”‚ è½®æ•°å¤æ‚åº¦    â”‚ å®¹é”™èƒ½åŠ›      â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ OMç®—æ³•          â”‚ O(n^(f+1))   â”‚ f+1          â”‚ n â‰¥ 3f+1     â”‚
â”‚ SMç®—æ³•          â”‚ O(nÂ²)        â”‚ f+1          â”‚ n â‰¥ 2f+1     â”‚
â”‚ PBFT            â”‚ O(nÂ²)        â”‚ 3            â”‚ n â‰¥ 3f+1     â”‚
â”‚ HotStuff        â”‚ O(n)         â”‚ 4            â”‚ n â‰¥ 3f+1     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### å®é™…æ€§èƒ½æµ‹è¯•

```java
import java.util.*;
import java.util.concurrent.ThreadLocalRandom;

public class PerformanceTest {

    /**
     * æ€§èƒ½æµ‹è¯•å‡½æ•°
     */
    public static Map<Integer, Map<String, Long>> performanceTest() {
        int[] nodeCounts = {4, 7, 10, 13, 16};
        String[] algorithms = {"OM", "SM", "PBFT"};

        Map<Integer, Map<String, Long>> results = new HashMap<>();

        for (int n : nodeCounts) {
            int f = (n - 1) / 3;
            Map<String, Long> algoResults = new HashMap<>();

            for (String algo : algorithms) {
                long startTime = System.currentTimeMillis();

                try {
                    if ("OM".equals(algo)) {
                        ByzantineGeneralsOM bg = new ByzantineGeneralsOM(n, f);
                        Set<Integer> byzantineNodes = new HashSet<>();
                        // éšæœºé€‰æ‹©fä¸ªæ‹œå åº­èŠ‚ç‚¹
                        for (int i = 0; i < f; i++) {
                            byzantineNodes.add(ThreadLocalRandom.current().nextInt(n));
                        }
                        bg.setByzantineNodes(byzantineNodes);
                        bg.oralMessage(1, f);

                    } else if ("SM".equals(algo)) {
                        ByzantineGeneralsSM bg = new ByzantineGeneralsSM(n, f);
                        Set<Integer> byzantineNodes = new HashSet<>();
                        for (int i = 0; i < f; i++) {
                            byzantineNodes.add(ThreadLocalRandom.current().nextInt(n));
                        }
                        bg.setByzantineNodes(byzantineNodes);
                        bg.signedMessageAlgorithm(1, 0);

                    } else if ("PBFT".equals(algo)) {
                        // æ¨¡æ‹ŸPBFTæ€§èƒ½
                        Thread.sleep(n * 10); // æ¨¡æ‹Ÿå¤æ‚åº¦
                    }
                } catch (Exception e) {
                    System.err.println("ç®—æ³• " + algo + " æ‰§è¡Œå¼‚å¸¸: " + e.getMessage());
                }

                long endTime = System.currentTimeMillis();
                algoResults.put(algo, endTime - startTime);
            }

            results.put(n, algoResults);
        }

        return results;
    }

    public static void main(String[] args) {
        Map<Integer, Map<String, Long>> perfResults = performanceTest();
        System.out.println("æ€§èƒ½æµ‹è¯•ç»“æœ (æ¯«ç§’):");

        for (Map.Entry<Integer, Map<String, Long>> entry : perfResults.entrySet()) {
            System.out.println("èŠ‚ç‚¹æ•° " + entry.getKey() + ": " + entry.getValue());
        }
    }
}
```
```

## ä¼˜åŒ–ç­–ç•¥

### 1. æ¶ˆæ¯èšåˆ

```java
import java.util.*;
import java.util.stream.Collectors;

class AggregatedSignature {
    private List<Integer> values;
    private List<Integer> signers;
    private String aggregatedSignature;

    public AggregatedSignature(List<Integer> values, List<Integer> signers, String signature) {
        this.values = values;
        this.signers = signers;
        this.aggregatedSignature = signature;
    }

    // Getters
    public List<Integer> getValues() { return values; }
    public List<Integer> getSigners() { return signers; }
    public String getAggregatedSignature() { return aggregatedSignature; }
}

public class OptimizedBFT {

    /**
     * èšåˆå¤šä¸ªç­¾åä»¥å‡å°‘é€šä¿¡å¼€é”€
     */
    public AggregatedSignature aggregateSignatures(List<SignedMessage> messages) {
        List<Integer> values = messages.stream()
            .map(SignedMessage::getValue)
            .collect(Collectors.toList());

        List<Integer> signers = messages.stream()
            .map(SignedMessage::getSenderId)
            .collect(Collectors.toList());

        // ä½¿ç”¨BLSç­¾åç­‰æŠ€æœ¯èšåˆç­¾å
        String aggregatedSig = blsAggregate(messages.stream()
            .flatMap(msg -> msg.getSignatureChain().stream())
            .map(SignatureEntry::getSignature)
            .collect(Collectors.toList()));

        return new AggregatedSignature(values, signers, aggregatedSig);
    }

    /**
     * æ‰¹é‡å¤„ç†äº‹åŠ¡ä»¥æé«˜ååé‡
     */
    public List<Boolean> batchProcessing(List<Transaction> transactions) {
        final int BATCH_SIZE = 1000;
        List<List<Transaction>> batches = new ArrayList<>();

        // åˆ†æ‰¹å¤„ç†
        for (int i = 0; i < transactions.size(); i += BATCH_SIZE) {
            int end = Math.min(i + BATCH_SIZE, transactions.size());
            batches.add(transactions.subList(i, end));
        }

        List<Boolean> results = new ArrayList<>();
        for (List<Transaction> batch : batches) {
            Boolean result = processTransactionBatch(batch);
            results.add(result);
        }

        return results;
    }

    /**
     * BLSç­¾åèšåˆï¼ˆç®€åŒ–å®ç°ï¼‰
     */
    private String blsAggregate(List<String> signatures) {
        // ç®€åŒ–å®ç°ï¼Œå®é™…ä¸­éœ€è¦ä½¿ç”¨çœŸæ­£çš„BLSç­¾ååº“
        return "aggregated_" + signatures.size() + "_signatures";
    }

    /**
     * å¤„ç†äº‹åŠ¡æ‰¹æ¬¡
     */
    private Boolean processTransactionBatch(List<Transaction> batch) {
        // ç®€åŒ–å®ç°
        System.out.println("å¤„ç†äº‹åŠ¡æ‰¹æ¬¡ï¼Œå¤§å°: " + batch.size());
        return true;
    }
}
```

### 2. å¼‚æ­¥ä¼˜åŒ–

```java
import java.util.*;
import java.util.concurrent.*;
import java.util.stream.Collectors;

class ConsensusResponse {
    private boolean valid;
    private int value;
    private int nodeId;

    public ConsensusResponse(boolean valid, int value, int nodeId) {
        this.valid = valid;
        this.value = value;
        this.nodeId = nodeId;
    }

    public boolean isValid() { return valid; }
    public int getValue() { return value; }
    public int getNodeId() { return nodeId; }
}

class ConsensusNode {
    private int id;
    private boolean isByzantine;

    public ConsensusNode(int id, boolean isByzantine) {
        this.id = id;
        this.isByzantine = isByzantine;
    }

    public CompletableFuture<ConsensusResponse> processMessage(int message) {
        return CompletableFuture.supplyAsync(() -> {
            try {
                // æ¨¡æ‹Ÿç½‘ç»œå»¶è¿Ÿ
                Thread.sleep(ThreadLocalRandom.current().nextInt(100, 500));

                if (isByzantine) {
                    // æ‹œå åº­èŠ‚ç‚¹å¯èƒ½è¿”å›é”™è¯¯å“åº”
                    return new ConsensusResponse(false, -1, id);
                } else {
                    // è¯šå®èŠ‚ç‚¹è¿”å›æ­£å¸¸å“åº”
                    return new ConsensusResponse(true, message, id);
                }
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
                return new ConsensusResponse(false, -1, id);
            }
        });
    }

    public int getId() { return id; }
}

public class AsyncByzantineConsensus {
    private List<ConsensusNode> nodes;
    private int f; // æœ€å¤§æ‹œå åº­èŠ‚ç‚¹æ•°
    private ExecutorService executor;

    public AsyncByzantineConsensus(List<ConsensusNode> nodes) {
        this.nodes = nodes;
        this.f = (nodes.size() - 1) / 3;
        this.executor = Executors.newCachedThreadPool();
    }

    /**
     * å¼‚æ­¥å…±è¯†ç®—æ³•
     */
    public CompletableFuture<Integer> asyncConsensus(int value) {
        List<CompletableFuture<ConsensusResponse>> tasks = new ArrayList<>();

        // å¹¶è¡Œå‘é€æ¶ˆæ¯åˆ°æ‰€æœ‰èŠ‚ç‚¹
        for (ConsensusNode node : nodes) {
            CompletableFuture<ConsensusResponse> task = sendMessageAsync(node, value);
            tasks.add(task);
        }

        // ç­‰å¾…æ‰€æœ‰å“åº”
        CompletableFuture<Void> allTasks = CompletableFuture.allOf(
            tasks.toArray(new CompletableFuture[0]));

        return allTasks.thenApply(v -> {
            // æ”¶é›†æ‰€æœ‰å“åº”
            List<ConsensusResponse> responses = tasks.stream()
                .map(CompletableFuture::join)
                .collect(Collectors.toList());

            // å¤„ç†å“åº”å¹¶è¾¾æˆå…±è¯†
            List<ConsensusResponse> validResponses = responses.stream()
                .filter(ConsensusResponse::isValid)
                .collect(Collectors.toList());

            if (validResponses.size() >= 2 * f + 1) {
                return computeConsensus(validResponses);
            }

            return null;
        });
    }

    /**
     * å¼‚æ­¥å‘é€æ¶ˆæ¯
     */
    private CompletableFuture<ConsensusResponse> sendMessageAsync(ConsensusNode node, int message) {
        return node.processMessage(message);
    }

    /**
     * è®¡ç®—å…±è¯†ç»“æœ
     */
    private Integer computeConsensus(List<ConsensusResponse> validResponses) {
        Map<Integer, Long> valueCounts = validResponses.stream()
            .collect(Collectors.groupingBy(
                ConsensusResponse::getValue,
                Collectors.counting()
            ));

        return valueCounts.entrySet().stream()
            .max(Map.Entry.comparingByValue())
            .map(Map.Entry::getKey)
            .orElse(null);
    }

    public void shutdown() {
        executor.shutdown();
    }

    // ä½¿ç”¨ç¤ºä¾‹
    public static void main(String[] args) throws Exception {
        List<ConsensusNode> nodes = Arrays.asList(
            new ConsensusNode(0, false),
            new ConsensusNode(1, false),
            new ConsensusNode(2, false),
            new ConsensusNode(3, true)  // æ‹œå åº­èŠ‚ç‚¹
        );

        AsyncByzantineConsensus consensus = new AsyncByzantineConsensus(nodes);

        CompletableFuture<Integer> result = consensus.asyncConsensus(1);
        Integer consensusValue = result.get(5, TimeUnit.SECONDS);

        System.out.println("å¼‚æ­¥å…±è¯†ç»“æœ: " + consensusValue);

        consensus.shutdown();
    }
}
```

## å®‰å…¨æ€§åˆ†æ

### æ”»å‡»æ¨¡å‹

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ æ‹œå åº­æ”»å‡»ç±»å‹                      â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ 1. æ¶ˆæ¯ä¼ªé€ æ”»å‡»                     â”‚
â”‚    â€¢ å‘é€è™šå‡æ¶ˆæ¯                   â”‚
â”‚    â€¢ ä¼ªé€ ç­¾å                       â”‚
â”‚                                     â”‚
â”‚ 2. å»¶è¿Ÿæ”»å‡»                         â”‚
â”‚    â€¢ æ•…æ„å»¶è¿Ÿæ¶ˆæ¯ä¼ é€’               â”‚
â”‚    â€¢ é€‰æ‹©æ€§å»¶è¿Ÿ                     â”‚
â”‚                                     â”‚
â”‚ 3. è”åˆæ”»å‡»                         â”‚
â”‚    â€¢ å¤šä¸ªæ‹œå åº­èŠ‚ç‚¹åè°ƒæ”»å‡»         â”‚
â”‚    â€¢ ç­–ç•¥æ€§æŠ•ç¥¨                     â”‚
â”‚                                     â”‚
â”‚ 4. å¥³å·«æ”»å‡»                         â”‚
â”‚    â€¢ åˆ›å»ºå¤šä¸ªè™šå‡èº«ä»½               â”‚
â”‚    â€¢ å¢åŠ æ¶æ„èŠ‚ç‚¹å½±å“åŠ›             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### é˜²å¾¡æœºåˆ¶

```java
import java.util.*;
import java.util.stream.Collectors;

class NodeHistory {
    private int nodeId;
    private List<String> messageHistory;
    private List<Long> timestamps;
    private List<Integer> votes;

    public NodeHistory(int nodeId) {
        this.nodeId = nodeId;
        this.messageHistory = new ArrayList<>();
        this.timestamps = new ArrayList<>();
        this.votes = new ArrayList<>();
    }

    public void addMessage(String message, long timestamp) {
        messageHistory.add(message);
        timestamps.add(timestamp);
    }

    public void addVote(int vote) {
        votes.add(vote);
    }

    // Getters
    public int getNodeId() { return nodeId; }
    public List<String> getMessageHistory() { return messageHistory; }
    public List<Long> getTimestamps() { return timestamps; }
    public List<Integer> getVotes() { return votes; }
}

class ReputationSystem {
    private Map<Integer, Double> reputations;

    public ReputationSystem() {
        this.reputations = new HashMap<>();
    }

    public double getReputation(int nodeId) {
        return reputations.getOrDefault(nodeId, 1.0); // é»˜è®¤å£°èª‰å€¼
    }

    public void updateReputation(int nodeId, double delta) {
        double currentRep = getReputation(nodeId);
        reputations.put(nodeId, Math.max(0.0, Math.min(1.0, currentRep + delta)));
    }
}

class IdentityVerification {
    private Set<Integer> verifiedNodes;

    public IdentityVerification() {
        this.verifiedNodes = new HashSet<>();
    }

    public boolean isVerified(int nodeId) {
        return verifiedNodes.contains(nodeId);
    }

    public void addVerifiedNode(int nodeId) {
        verifiedNodes.add(nodeId);
    }
}

public class SecurityMechanism {
    private ReputationSystem reputationSystem;
    private IdentityVerification identityVerification;
    private double reputationThreshold;

    public SecurityMechanism() {
        this.reputationSystem = new ReputationSystem();
        this.identityVerification = new IdentityVerification();
        this.reputationThreshold = 0.5;
    }

    /**
     * æ£€æµ‹æ‹œå åº­è¡Œä¸º
     */
    public boolean detectByzantineBehavior(NodeHistory nodeHistory) {
        boolean[] suspiciousPatterns = {
            checkMessageConsistency(nodeHistory),
            checkTimingAnomalies(nodeHistory),
            checkVotingPatterns(nodeHistory)
        };

        // å¦‚æœä»»ä½•ä¸€ä¸ªæ¨¡å¼å¯ç–‘ï¼Œåˆ™è®¤ä¸ºå¯èƒ½æ˜¯æ‹œå åº­èŠ‚ç‚¹
        return Arrays.stream(suspiciousPatterns).anyMatch(pattern -> pattern);
    }

    /**
     * åŸºäºå£°èª‰çš„æ¶ˆæ¯è¿‡æ»¤
     */
    public List<SignedMessage> reputationBasedFiltering(List<SignedMessage> messages) {
        return messages.stream()
            .filter(msg -> {
                double senderReputation = reputationSystem.getReputation(msg.getSenderId());
                return senderReputation > reputationThreshold;
            })
            .collect(Collectors.toList());
    }

    /**
     * æ£€æŸ¥æ¶ˆæ¯ä¸€è‡´æ€§
     */
    private boolean checkMessageConsistency(NodeHistory history) {
        List<String> messages = history.getMessageHistory();
        if (messages.size() < 2) return false;

        // ç®€åŒ–æ£€æŸ¥ï¼šæ£€æŸ¥æ˜¯å¦æœ‰ç›¸äº’çŸ›ç›¾çš„æ¶ˆæ¯
        Set<String> uniqueMessages = new HashSet<>(messages);
        return uniqueMessages.size() < messages.size() * 0.8; // å¦‚æœé‡å¤æ¶ˆæ¯è¿‡å¤š
    }

    /**
     * æ£€æŸ¥æ—¶é—´å¼‚å¸¸
     */
    private boolean checkTimingAnomalies(NodeHistory history) {
        List<Long> timestamps = history.getTimestamps();
        if (timestamps.size() < 3) return false;

        // æ£€æŸ¥æ˜¯å¦æœ‰å¼‚å¸¸çš„æ—¶é—´é—´éš”
        for (int i = 1; i < timestamps.size(); i++) {
            long interval = timestamps.get(i) - timestamps.get(i-1);
            if (interval < 0 || interval > 10000) { // 10ç§’ä»¥ä¸Šçš„é—´éš”å¯èƒ½å¼‚å¸¸
                return true;
            }
        }
        return false;
    }

    /**
     * æ£€æŸ¥æŠ•ç¥¨æ¨¡å¼
     */
    private boolean checkVotingPatterns(NodeHistory history) {
        List<Integer> votes = history.getVotes();
        if (votes.size() < 5) return false;

        // æ£€æŸ¥æ˜¯å¦æœ‰å¼‚å¸¸çš„æŠ•ç¥¨æ¨¡å¼ï¼ˆä¾‹å¦‚æ€»æ˜¯æŠ•åå¯¹ç¥¨ï¼‰
        long negativeVotes = votes.stream().mapToLong(vote -> vote < 0 ? 1 : 0).sum();
        return (double) negativeVotes / votes.size() > 0.8; // 80%ä»¥ä¸Šçš„åå¯¹ç¥¨
    }

    public void setReputationThreshold(double threshold) {
        this.reputationThreshold = threshold;
    }
}
```

## æ€»ç»“

æ‹œå åº­å°†å†›é—®é¢˜ä¸ºåˆ†å¸ƒå¼ç³»ç»Ÿçš„å®¹é”™è®¾è®¡æä¾›äº†ç†è®ºåŸºç¡€ï¼š

### å…³é”®è¦ç‚¹

1. **ç†è®ºé™åˆ¶**ï¼šn â‰¥ 3f + 1 æ˜¯æ‹œå åº­å®¹é”™çš„åŸºæœ¬è¦æ±‚
2. **ç®—æ³•é€‰æ‹©**ï¼šæ ¹æ®ç½‘ç»œç¯å¢ƒå’Œæ€§èƒ½è¦æ±‚é€‰æ‹©åˆé€‚çš„ç®—æ³•
3. **å®é™…åº”ç”¨**ï¼šåœ¨åŒºå—é“¾ã€åˆ†å¸ƒå¼æ•°æ®åº“ç­‰ç³»ç»Ÿä¸­å¹¿æ³›åº”ç”¨
4. **ä¼˜åŒ–æ–¹å‘**ï¼šé€šè¿‡ç­¾åèšåˆã€æ‰¹å¤„ç†ç­‰æŠ€æœ¯æé«˜æ€§èƒ½

### æŠ€æœ¯æ¼”è¿›

```
ç»å…¸æ‹œå åº­å®¹é”™
      â†“
å®ç”¨æ‹œå åº­å®¹é”™(PBFT)
      â†“
é«˜æ•ˆBFTç®—æ³•(HotStuff, Tendermint)
      â†“
åŒºå—é“¾å…±è¯†æœºåˆ¶(PoS, DPoS)
```

æ‹œå åº­å°†å†›é—®é¢˜ä¸ä»…æ˜¯ç†è®ºç ”ç©¶çš„ç»å…¸é—®é¢˜ï¼Œæ›´æ˜¯ç°ä»£åˆ†å¸ƒå¼ç³»ç»Ÿè®¾è®¡å¿…é¡»è€ƒè™‘çš„æ ¸å¿ƒæŒ‘æˆ˜ã€‚ç†è§£è¿™ä¸ªé—®é¢˜åŠå…¶è§£å†³æ–¹æ¡ˆï¼Œå¯¹äºæ„å»ºå¯é çš„åˆ†å¸ƒå¼ç³»ç»Ÿè‡³å…³é‡è¦ã€‚

## å‚è€ƒèµ„æ–™

1. Lamport, L., Shostak, R., & Pease, M. (1982). The Byzantine Generals Problem
2. Castro, M., & Liskov, B. (1999). Practical Byzantine Fault Tolerance
3. Yin, M., Malkhi, D., Reiter, M. K., Golan-Gueta, G., & Abraham, I. (2019). HotStuff